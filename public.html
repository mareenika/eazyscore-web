<script type="module">
  import { createClient } from "https://esm.sh/@supabase/supabase-js";

  const supabase = createClient(
    "https://lhdztkfvrnsqfnbqybfq.supabase.co",
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxoZHp0a2Z2cm5zcWZuYnF5YmZxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczMjIxMjMsImV4cCI6MjA3Mjg5ODEyM30.81BVX5zf_WxE3RdTw32OttwsiMgDanXdNIkWeug-jUs"
  );

  const cards = document.getElementById('cards');
  const searchInput = document.getElementById('search');
  const countEl = document.getElementById('count');
  const latestEmpty = document.getElementById('latestEmpty');
  const latestErr = document.getElementById('latestErr');

  const appsTbody = document.getElementById('appsTbody');
  const appsEmpty = document.getElementById('appsEmpty');
  const appsErr = document.getElementById('appsErr');

  // Vorschläge
  const suggForm = document.getElementById('suggForm');
  const suggName = document.getElementById('suggName');
  const suggUrl  = document.getElementById('suggUrl');
  const suggNote = document.getElementById('suggNote');
  const suggMsg  = document.getElementById('suggMsg');
  const suggTbody= document.getElementById('suggTbody');
  const suggEmpty= document.getElementById('suggEmpty');
  const suggErr  = document.getElementById('suggErr');
  const hp       = document.getElementById('hp');

  const fmtDate = iso => new Date(iso).toLocaleString('de-DE', { dateStyle:'medium', timeStyle:'short' });
  const escape = s => (s||'').replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

  // ---------- Laden & Rendern ----------
  let cache = { apps: [], assessments: [], suggestions: [] };

  async function loadAppsAndAssessments() {
    latestErr.style.display = 'none';
    try {
      const [appsRes, assessRes] = await Promise.all([
        supabase.from('v_apps_public').select('*').order('name', { ascending:true }).limit(1000),
        supabase.from('v_assessments_public').select('*').order('created_at', { ascending:false }).limit(1000)
      ]);
      if (appsRes.error) throw appsRes.error;
      if (assessRes.error) throw assessRes.error;

      cache.apps = appsRes.data || [];
      cache.assessments = assessRes.data || [];
      renderAll();
    } catch (err) {
      console.error(err);
      latestErr.textContent = 'Fehler beim Laden der Bewertungen: ' + (err?.message || err);
      latestErr.style.display = 'block';
    }
  }

  function renderAll() {
    // Indexe
    const appById = Object.create(null);
    cache.apps.forEach(a => { appById[a.id] = a; });

    // Neueste Bewertung je App
    const latestByApp = new Map();
    cache.assessments.forEach(a => {
      if (!latestByApp.has(a.app_id)) latestByApp.set(a.app_id, a);
    });
    const latestPerApp = Array.from(latestByApp.values())
      .sort((a,b)=> new Date(b.created_at)-new Date(a.created_at))
      .slice(0, 100);

    function gradeColor(g){ return ({A:'#16a34a',B:'#22c55e',C:'#84cc16',D:'#eab308',E:'#f59e0b',F:'#ef4444'}[g] || '#6b7280'); }

    function renderCards(list){
      cards.innerHTML = '';
      if (!list.length) { latestEmpty.style.display = 'block'; countEl.textContent = '0 Einträge'; return; }
      latestEmpty.style.display = 'none';
      list.forEach(a => {
        const app = appById[a.app_id] || {};
        const name = escape(app.name)||'Unbekannte App';
        const cat  = escape(app.category)||'–';
        const score = a.total_score ?? 0;
        const grade = a.grade || '–';
        const when  = fmtDate(a.created_at);
        const el = document.createElement('div');
        el.className = 'card';
        el.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.25rem">
            <div style="font-weight:600">${name}${app.version ? ` <span class="muted">(${escape(app.version)})</span>`:''}</div>
            <span class="tag">${cat}</span>
          </div>
          <div class="score" style="color:${gradeColor(grade)}">${Math.round(score)}%</div>
          <div class="grade" style="color:${gradeColor(grade)}">Note ${grade}</div>
          <div class="muted" style="margin-top:.25rem">${when}</div>
        `;
        cards.appendChild(el);
      });
      countEl.textContent = `${list.length} Einträge`;
    }

    // Suche
    const q = (searchInput.value||'').trim().toLowerCase();
    const list = !q ? latestPerApp : latestPerApp.filter(a => {
      const app = appById[a.app_id] || {};
      return (app.name||'').toLowerCase().includes(q) ||
             (app.category||'').toLowerCase().includes(q) ||
             (app.version||'').toLowerCase().includes(q);
    });
    renderCards(list);

    // Katalog (alphabetisch)
    appsTbody.innerHTML = '';
    if (!cache.apps.length) {
      appsEmpty.style.display = 'block';
    } else {
      appsEmpty.style.display = 'none';
      cache.apps.forEach(a => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${escape(a.name)}</td>
          <td>${escape(a.version)||'–'}</td>
          <td>${escape(a.category)||'–'}</td>
          <td class="muted">${escape(a.bundle_id)||'–'}</td>
          <td class="muted">${fmtDate(a.created_at)}</td>
        `;
        appsTbody.appendChild(tr);
      });
    }
  }

  searchInput.addEventListener('input', renderAll);

  // ---------- Vorschläge ----------
  async function loadSuggestions(){
    suggErr.style.display = 'none';
    suggTbody.innerHTML = '';
    suggEmpty.style.display = 'none';

    const { data, error } = await supabase
      .from('app_suggestions')
      .select('id, app_name, store_url, note, created_at')
      .order('created_at', { ascending:false })
      .limit(200);
    if (error) {
      suggErr.textContent = 'Fehler beim Laden der Vorschläge: ' + error.message;
      suggErr.style.display = 'block';
      return;
    }
    cache.suggestions = data || [];
    if (!cache.suggestions.length) {
      suggEmpty.style.display = 'block';
      return;
    }
    cache.suggestions.forEach(s => {
      const tr = document.createElement('tr');
      tr.dataset.id = s.id;
      tr.innerHTML = `
        <td>${escape(s.app_name)}</td>
        <td class="muted">${s.store_url ? `<a href="${escape(s.store_url)}" target="_blank" rel="noopener">Link</a>` : '–'}</td>
        <td class="muted">${escape(s.note)||'–'}</td>
        <td class="muted">${fmtDate(s.created_at)}</td>
      `;
      suggTbody.appendChild(tr);
    });
  }

  // Vorschlag einreichen (Gäste erlaubt) + Honeypot
  const hp = document.getElementById('hp');
  const suggFormEl = document.getElementById('suggForm');
  suggFormEl?.addEventListener('submit', async (e) => {
    e.preventDefault();
    suggMsg.textContent = '';
    suggErr.style.display = 'none';
    if (hp.value) return; // Bot

    const name = (suggName.value||'').trim();
    const url  = (suggUrl.value||'').trim();
    const note = (suggNote.value||'').trim();
    if (!name) { suggMsg.textContent = 'Bitte App-Name angeben.'; return; }

    const { error } = await supabase.from('app_suggestions').insert({
      app_name: name, store_url: url || null, note: note || null
    });
    if (error) {
      suggErr.textContent = 'Fehler beim Senden: ' + error.message;
      suggErr.style.display = 'block';
      return;
    }
    suggName.value=''; suggUrl.value=''; suggNote.value='';
    suggMsg.textContent = 'Danke! Vorschlag wurde gespeichert.';
    await loadSuggestions();
  });

  // ---------- Realtime-Updates (löschen/einfügen/ändern sehen Gäste sofort) ----------
  function setupRealtime() {
    const ch = supabase.channel('public_live');

    // assessments (bewertete Einträge)
    ch.on('postgres_changes', { event: '*', schema: 'public', table: 'assessments' }, async () => {
      await loadAppsAndAssessments();
    });

    // apps (wenn Admin App löscht/bearbeitet)
    ch.on('postgres_changes', { event: '*', schema: 'public', table: 'apps' }, async () => {
      await loadAppsAndAssessments();
    });

    // Vorschläge (Gäste/Admins)
    ch.on('postgres_changes', { event: '*', schema: 'public', table: 'app_suggestions' }, async () => {
      await loadSuggestions();
    });

    ch.subscribe((status) => {
      // optional: console.log('Realtime status:', status);
    });
  }

  // Init
  await Promise.all([loadAppsAndAssessments(), loadSuggestions()]);
  setupRealtime();
</script>
